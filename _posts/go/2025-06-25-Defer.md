---
title: Using defer in Go
date: 2025-06-25 12:10:00 -0700
categories: [Programming, Go]
tags: [go, defer, control-flow, cleanup]
---

`defer` schedules a function call to run just before the surrounding function returns—no matter which return path is taken (success, early return, even a panic unless the process exits). Arguments to the deferred call are evaluated immediately; only execution is delayed.

Typical uses:
- Closing files (`defer f.Close()`)
- Unlocking mutexes (`defer mu.Unlock()`)
- Rolling back or committing transactions
- Flushing buffers / writers
- Timing / tracing (`defer span.End()`)

## Basic Example

```go
func GetUsername(srcName string) (string, error) {
    conn, err := db.Open(srcName)
    if err != nil {
        return "", err
    }
    defer conn.Close() // always runs

    username, err := db.FetchUser()
    if err != nil {
        return "", err
    }
    return username, nil
}
```

The cleanup happens exactly once, even with multiple returns.

## Multiple Defers

Multiple deferred calls execute in last‑in, first‑out (stack) order.

```go
defer fmt.Println("third")
defer fmt.Println("second")
defer fmt.Println("first")
// prints:
// first
// second
// third
```

## Assignment

Goal: Ensure `bootup` prints `TEXTIO BOOTUP DONE` exactly once regardless of which return path is taken.

Starter (repetitive version):

```go
func bootup() {
    ok := connectToDB()
    if !ok {
        fmt.Println("TEXTIO BOOTUP DONE")
        return
    }

    ok = connectToPaymentProvider()
    if !ok {
        fmt.Println("TEXTIO BOOTUP DONE")
        return
    }

    fmt.Println("All systems ready!")
    fmt.Println("TEXTIO BOOTUP DONE")
}
```

Refactor with a single `defer`:

```go
package main

import "fmt"

func bootup() {
    defer fmt.Println("TEXTIO BOOTUP DONE")

    ok := connectToDB()
    if !ok {
        return
    }

    ok = connectToPaymentProvider()
    if !ok {
        return
    }

    fmt.Println("All systems ready!")
}

// --- below this line is harness ---

var shouldConnectToDB = true

func connectToDB() bool {
    fmt.Println("Connecting to database...")
    if shouldConnectToDB {
        fmt.Println("Connected!")
        return true
    }
    fmt.Println("Connection failed")
    return false
}

var shouldConnectToPaymentProvider = true

func connectToPaymentProvider() bool {
    fmt.Println("Connecting to payment provider...")
    if shouldConnectToPaymentProvider {
        fmt.Println("Connected!")
        return true
    }
    fmt.Println("Connection failed")
    return false
}

func test(dbSuccess, paymentSuccess bool) {
    shouldConnectToDB = dbSuccess
    shouldConnectToPaymentProvider = paymentSuccess
    bootup()
    fmt.Println("====================================")
}

func main() {
    test(true, true)
    test(false, true)
    test(true, false)
    test(false, false)
}
```

Run it; observe the message prints last every time.

## Tips

- Keep deferred calls cheap in hot loops (they add a small allocation if arguments capture stack variables).
- Prefer a single defer for symmetric open/close scopes.
- Capture error handling patterns with named return values plus a deferred closure if you need post‑processing.

## Summary

`defer` centralizes cleanup logic, eliminating duplication across early returns and improving reliability.

*Adapted from community practices and resources such