---
title: Switch Statements in Go
date: 2025-06-23 12:00:00 -0700
categories: [Programming, Go]
tags: [go, switch, control-flow]
---

`switch` provides a readable way to compare one value against several alternatives. It replaces long `if / else if` ladders.

## Basic `switch`

```go
func getCreator(os string) string {
    var creator string
    switch os {
    case "linux":
        creator = "Linus Torvalds"
    case "windows":
        creator = "Bill Gates"
    case "mac":
        creator = "A Steve"
    default:
        creator = "Unknown"
    }
    return creator
}
```

Key points:
- Only the first matching `case` runs; an implicit `break` stops further evaluation.
- `default` executes when no other case matches.

## Falling Through

Use `fallthrough` to force execution of the *next* case’s statements (rarely needed).

```go
func getCreator(os string) string {
    switch os {
    case "linux":
        return "Linus Torvalds"
    case "windows":
        return "Bill Gates"
    case "macOS":
        fallthrough
    case "Mac OS X":
        fallthrough
    case "mac":
        return "A Steve"
    default:
        return "Unknown"
    }
}
```

## Expression‑less Switch

You can switch on `true` for chained conditionals:

```go
func classify(n int) string {
    switch {
    case n < 0:
        return "negative"
    case n == 0:
        return "zero"
    default:
        return "positive"
    }
}
```

## Type Switch (Preview)

When working with interfaces:

```go
func describe(v any) string {
    switch v.(type) {
    case int:
        return "int"
    case string:
        return "string"
    default:
        return "other"
    }
}
```

## Assignment

Fix the bug: the original `billingCost` only handled `"basic"` (shown first). Add `"pro"` (20.0) and `"enterprise"` (50.0)`; return `0.0` for anything else.

Buggy version:

```go
func billingCost(plan string) float64 {
    switch plan {
    case "basic":
        return 10.0
    default:
        return 0.0
    }
}
```

Corrected version (solution):

```go
package main

import "fmt"

func billingCost(plan string) float64 {
    switch plan {
    case "basic":
        return 10.0
    case "pro":
        return 20.0
    case "enterprise":
        return 50.0
    default:
        return 0.0
    }
}

// don't touch below this line
func main() {
    plan := "basic"
    fmt.Printf("The cost for a %s plan is $%.2f\n", plan, billingCost(plan))
    plan = "pro"
    fmt.Printf("The cost for a %s plan is $%.2f\n", plan, billingCost(plan))
    plan = "enterprise"
    fmt.Printf("The cost for a %s plan is $%.2f\n", plan, billingCost(plan))
    plan = "free"
    fmt.Printf("The cost for a %s plan is $%.2f\n", plan, billingCost(plan))
    plan = "unknown"
    fmt.Printf("The cost for a %s plan is $%.2f\n", plan, billingCost(plan))
}
```

Try extending it: add a `"free"` plan returning `0.0` explicitly, then group it with `"trial"` using a comma-separated case list.

## Summary

Use `switch` for clarity when branching on one value. Avoid unnecessary `fallthrough`; prefer separate cases or grouping. Type and expression‑less switches add flexibility without sacrificing readability.

*Adapted from community practices and resources such as [boot.dev](https://boot.dev/)